import itertools
import copy
from copy import deepcopy

#####################################################################################Que des constates, aucun calcul à faire###############################################################################################################
table_ln = [0x4, 0x5, 0x6, 0x7, 0x0, 0x1, 0x2, 0x3, # Round 0
            0x5, 0x4, 0x7, 0x6, 0x1, 0x0, 0x3, 0x2, # Round 1
            0x6, 0x7, 0x4, 0x5, 0x2, 0x3, 0x0, 0x1, # ...
            0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0, 
            0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
            0x1, 0x0, 0x3, 0x2, 0x5, 0x4, 0x7, 0x6,
            0x2, 0x3, 0x0, 0x1, 0x6, 0x7, 0x4, 0x5,
            0x3, 0x2, 0x1, 0x0, 0x7, 0x6, 0x5, 0x4,
            0x5, 0x4, 0x7, 0x6, 0x1, 0x0, 0x3, 0x2,
            0x4, 0x5, 0x6, 0x7, 0x0, 0x1, 0x2, 0x3,
            0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0, 
            0x6, 0x7, 0x4, 0x5, 0x2, 0x3, 0x0, 0x1,
            0x1, 0x0, 0x3, 0x2, 0x5, 0x4, 0x7, 0x6,
            0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
            0x3, 0x2, 0x1, 0x0, 0x7, 0x6, 0x5, 0x4,
            0x2, 0x3, 0x0, 0x1, 0x6, 0x7, 0x4, 0x5,
            0x6, 0x7, 0x4, 0x5, 0x2, 0x3, 0x0, 0x1,
            0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0,
            0x4, 0x5, 0x6, 0x7, 0x0, 0x1, 0x2, 0x3,
            0x5, 0x4, 0x7, 0x6, 0x1, 0x0, 0x3, 0x2,
            0x2, 0x3, 0x0, 0x1, 0x6, 0x7, 0x4, 0x5,
            0x3, 0x2, 0x1, 0x0, 0x7, 0x6, 0x5, 0x4,
            0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
            0x1, 0x0, 0x3, 0x2, 0x5, 0x4, 0x7, 0x6] # Round 24

table_un = [0x1, 0x0, 0x3, 0x2, 0x5, 0x4, 0x7, 0x6, # Round 0
            0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, # Round 1
            0x3, 0x2, 0x1, 0x0, 0x7, 0x6, 0x5, 0x4, # ...
            0x2, 0x3, 0x0, 0x1, 0x6, 0x7, 0x4, 0x5, 
            0x5, 0x4, 0x7, 0x6, 0x1, 0x0, 0x3, 0x2, 
            0x4, 0x5, 0x6, 0x7, 0x0, 0x1, 0x2, 0x3, 
            0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0, 
            0x6, 0x7, 0x4, 0x5, 0x2, 0x3, 0x0, 0x1, 
            0x3, 0x2, 0x1, 0x0, 0x7, 0x6, 0x5, 0x4,
            0x2, 0x3, 0x0, 0x1, 0x6, 0x7, 0x4, 0x5, 
            0x1, 0x0, 0x3, 0x2, 0x5, 0x4, 0x7, 0x6, 
            0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
            0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0,
            0x6, 0x7, 0x4, 0x5, 0x2, 0x3, 0x0, 0x1,
            0x5, 0x4, 0x7, 0x6, 0x1, 0x0, 0x3, 0x2,
            0x4, 0x5, 0x6, 0x7, 0x0, 0x1, 0x2, 0x3,
            0x2, 0x3, 0x0, 0x1, 0x6, 0x7, 0x4, 0x5,
            0x3, 0x2, 0x1, 0x0, 0x7, 0x6, 0x5, 0x4,
            0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7,
            0x1, 0x0, 0x3, 0x2, 0x5, 0x4, 0x7, 0x6,
            0x6, 0x7, 0x4, 0x5, 0x2, 0x3, 0x0, 0x1,
            0x7, 0x6, 0x5, 0x4, 0x3, 0x2, 0x1, 0x0,
            0x4, 0x5, 0x6, 0x7, 0x0, 0x1, 0x2, 0x3,
            0x5, 0x4, 0x7, 0x6, 0x1, 0x0, 0x3, 0x2] # Round 24
# AUT64 la table T_offset pour la fonction de compression         
# octet d'entrée:   0    1    2    3    4    5    6    7    8    9    A    B    C    D    E    F  | octet de clé               
table_offset = [ 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, # 0
                 0x0, 0x1, 0x2, 0x3, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, 0xB, 0xC, 0xD, 0xE, 0xF, # 1
                 0x0, 0x2, 0x4, 0x6, 0x8, 0xA, 0xC, 0xE, 0x3, 0x1, 0x7, 0x5, 0xB, 0x9, 0xF, 0xD, # 2
                 0x0, 0x3, 0x6, 0x5, 0xC, 0xF, 0xA, 0x9, 0xB, 0x8, 0xD, 0xE, 0x7, 0x4, 0x1, 0x2, # 3
                 0x0, 0x4, 0x8, 0xC, 0x3, 0x7, 0xB, 0xF, 0x6, 0x2, 0xE, 0xA, 0x5, 0x1, 0xD, 0x9, # 4
                 0x0, 0x5, 0xA, 0xF, 0x7, 0x2, 0xD, 0x8, 0xE, 0xB, 0x4, 0x1, 0x9, 0xC, 0x3, 0x6, # 5
                 0x0, 0x6, 0xC, 0xA, 0xB, 0xD, 0x7, 0x1, 0x5, 0x3, 0x9, 0xF, 0xE, 0x8, 0x2, 0x4, # 6
                 0x0, 0x7, 0xE, 0x9, 0xF, 0x8, 0x1, 0x6, 0xD, 0xA, 0x3, 0x4, 0x2, 0x5, 0xC, 0xB, # 7
                 0x0, 0x8, 0x3, 0xB, 0x6, 0xE, 0x5, 0xD, 0xC, 0x4, 0xF, 0x7, 0xA, 0x2, 0x9, 0x1, # 8
                 0x0, 0x9, 0x1, 0x8, 0x2, 0xB, 0x3, 0xA, 0x4, 0xD, 0x5, 0xC, 0x6, 0xF, 0x7, 0xE, # 9
                 0x0, 0xA, 0x7, 0xD, 0xE, 0x4, 0x9, 0x3, 0xF, 0x5, 0x8, 0x2, 0x1, 0xB, 0x6, 0xC, # A
                 0x0, 0xB, 0x5, 0xE, 0xA, 0x1, 0xF, 0x4, 0x7, 0xC, 0x2, 0x9, 0xD, 0x6, 0x8, 0x3, # B
                 0x0, 0xC, 0xB, 0x7, 0x5, 0x9, 0xE, 0x2, 0xA, 0x6, 0x1, 0xD, 0xF, 0x3, 0x4, 0x8, # C
                 0x0, 0xD, 0x9, 0x4, 0x1, 0xC, 0x8, 0x5, 0x2, 0xF, 0xB, 0x6, 0x3, 0xE, 0xA, 0x7, # D
                 0x0, 0xE, 0xF, 0x1, 0xD, 0x3, 0x2, 0xC, 0x9, 0x7, 0x6, 0x8, 0x4, 0xA, 0xB, 0x5, # E
                 0x0, 0xF, 0xD, 0x2, 0x9, 0x6, 0x4, 0xB, 0x1, 0xE, 0xC, 0x3, 0x8, 0x7, 0x5, 0xA ]# F

# AUT64 table de substitution                                  
table_sub = [0x0, 0x1, 0x9, 0xE, 0xD, 0xB, 0x7, 0x6, 0xF, 0x2, 0xC, 0x5, 0xA, 0x4, 0x3, 0x8]

#AUT64 table TD utilisé pour reconstituer la clé KG
table_td=[0x7D, 0x56, 0x99, 0x65, 0x8C, 0x74, 0x82, 0x83,
          0x9B, 0x92, 0x7B, 0xA1, 0xAA, 0xB0, 0x64, 0xCF,
          0xB9, 0xDE, 0x5D, 0xED, 0xC8, 0xFC, 0x46, 0x0B,
          0xD7, 0x1A, 0x3F, 0x29, 0xC6, 0x38, 0x28, 0x47]

###############################################################################################Fonction de compression G##############################################################################################################################################




# AUT64 Compression function G
# Inputs: state   - 64-bit bitstring round state
#         key_reg - 32-bit bitstring compression function key k_G
#         roundN  - AUT64 round number [0-11]
#         verbose - Provide detailed operations
# Returns: 8-bit integer x'_7
def compress(state, key_reg, roundN):
    r5 = 0
    r6 = 0
    for byte in range(0, 7): # Compute over first 7 bytes
        ## lower nibble in byte ##  
        ln = state[byte] & 0xf # get lower byte nibble
        lk = key_reg[table_ln[8*roundN + byte]] # get key nibble
        p0 = ln | ((lk << 4) & 0xf0) # combine state and key nibble    
        r6 ^= table_offset[p0]
        
        ## upper nibble in byte ##
        un = (state[byte] >> 4) & 0xf # get upper byte nibble
        uk = key_reg[table_un[8*roundN + byte]] # get key nibble  
        p1 = un | ((uk << 4) & 0xf0) # combine state and key nibble uk,un
        r5 ^= table_offset[p1]
    ## Compute final byte (7)
    
    ## lower nibble in byte ##
    ln = state[7] & 0xf # get lower byte nibble
    lk = key_reg[table_ln[8*roundN + 7]] # get lower key nibble   
    ls = (table_sub[lk] << 4) & 0xf0    # Substitute and move lower into upper nibble

    # Find index of ln in table_offset at ls+(0,1,2,...,15)
    for i_ln in range(0,16):
        if table_offset[ls + i_ln] == ln:
            break
    r6 ^= i_ln
    ## upper nibble in byte ##
    un = (state[7] >> 4) & 0xf # get upper byte nibble
    uk = key_reg[table_un[8*roundN + 7]] # get upper key nibble   
    us = (table_sub[uk] << 4) & 0xf0    # Substitute and move lower into upper nibble

    #Find index of ln in table_offset at ls+(0,1,2,...,15)
    for i_un in range(0,16):
        if table_offset[us + i_un] == un:
            break
    r5 ^= i_un
    
    result = ((r5 << 4) & 0xf0) | (r6 & 0x0f) #r5,r6
            
    return result
#############################################################################################################################################################################################################################################


# Apply 4x4 sbox nibble wise to byte
# Returns: 8-bit integer result
def apply_sbox(byte, sbox):
    result = 0
    
    # Lower nibble
    result = sbox[byte & 0xf]
    # Upper nibble
    result = result|sbox[(byte >> 4) & 0x0f] << 4
    
    return result

# Apply pbox to input_data(list of input bytes) n times
# Returns: 8-bit integer result 
def apply_pbox(input_data, pbox, n):
    input_data_copy = copy.copy(input_data)

    for rnd in range(0,n):
        output_data = [0]*8
        for bIdx,byte in enumerate(input_data_copy):
            output_data[pbox[bIdx]] = input_data_copy[bIdx]        
        input_data_copy = copy.copy(output_data)
        
    return output_data 


# Apply pbox to 8-bit input_data bitwise
# Returns: 8-bit bitwise permuted input_data as integer
def apply_pbox_bitwise(input_data, pbox):
    result = 0

    for bit in range(8):
        if (input_data & (1 << bit)):
            result |= (1 << pbox[bit])

    return result

# AUT64 encryption function
# Inputs: state   - 64-bit bitstring message m
#         key_reg - 32-bit bitstring compression function key k_G
#         pbox    - 8-element AUT64 permutation key part k_perm
#         sbox    - 4x4 AUT64 sbox key part k_sub
#         nRounds - nRounds of AUT64 round function to apply
#         verbose - Provide detailed operations
# Returns: 64-bit AUT64 encryption as list of hex strings
def encrypt(state, key_reg, pbox, sbox, nRounds):

    stateInternal = copy.deepcopy(state)

    for roundN in range(0,nRounds):
        stateInternal = apply_pbox(stateInternal,pbox,1) 
        step1 = compress(stateInternal, key_reg, roundN)    
        step2 = list( bin( apply_sbox(step1, sbox) )[2:].zfill(8) ) 
        step2 = int(''.join(step2), 2)
        step3 = apply_pbox_bitwise(step2, pbox)
    
        step4 = int( apply_sbox(step3, sbox) )
        stateInternal[7] = step4

    return stateInternal                   
##################################################################################################Exemple d'exécution########################################################################################################################
if __name__ == "__main__":
    key_reg = [12, 6, 4, 14, 5, 4, 8, 11]
    P= [0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8]
    pbox = [2, 6, 0, 5, 7, 4, 3, 1]
    sbox=[0, 1, 2, 3, 4, 5, 7, 11, 6, 8, 10, 9, 13, 12, 15, 14]
    nRounds=8
    C=encrypt(P,key_reg,pbox,sbox,nRounds)
    print("le message chiffré est", C)




